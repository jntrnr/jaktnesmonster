import cart { Mirroring }

class RGB {
    public red: u8
    public green: u8
    public blue: u8
}

class Sprite {
    public hflip: bool
    public mask: [u8]
    public bg_sprite: bool
    public sprite_x: u8
    public sprite_zero: bool

    public function get_sprite_pixel(this, x: u8) -> (bool, u8){

        //TODO (?): How did the hardware handle this with 8 bits?
        guard x >= .sprite_x and (x as! u16) < ((.sprite_x as! u16) + 8u16) else {
            return(false, 0u8)
        }

        mut shift_amount = match .hflip {
            true => (x - .sprite_x) as! i16
            else => 7 - (x as! i16 - .sprite_x as! i16)
        }

        if (shift_amount < 0) {
            shift_amount = 0
        }

        let entry = .mask[shift_amount as! u8]

        return (true, entry)
    }
}

class PPU {
    // base_table_address: u16
    vram_address_increment: u16
    sprite_table_address: u16
    background_table_address: u16
    sprite_size_8x8: bool
    public nmi_on_vblank: bool
    clock: u64
    public in_vblank: bool
    dont_vblank: bool
    vram: [u8]
    // public vram_rw_addr: u16
    public oam: [u8]
    oam_addr: u8
    second_oam: [Sprite]
    vram_page_0000: [u8]
    vram_page_1000: [u8]
    public video_buffer: [RGB]
    // scroll_x: u8
    // scroll_y: u8
    // scroll_toggle: bool
    background_visible: bool
    sprites_visible: bool
    buffered_read: u8
    sprite_zero_hit: bool
    sprite_overflow: bool
    public debug: bool
    rendering_enabled: bool
    even_frame_flag: bool
    horizontal_pixel: u64
    vertical_pixel: u64
    mirroring: Mirroring

    // Internal PPU registers (from https://www.nesdev.org/wiki/PPU_scrolling)
    v: u16
    t: u16
    x: u8
    w: u8

    color_palette: [RGB]

    public function init(vram_page_0000: [u8], vram_page_1000: [u8], mirroring: Mirroring) throws -> PPU {
        mut video_buffer: [RGB] = []
        for _ in 0..(256*240) {
            video_buffer.push(rgb(0, 0, 0))
        }
        return PPU(
            vram_address_increment: 1
            sprite_table_address: 0x0000
            background_table_address: 0x0000
            sprite_size_8x8: true
            nmi_on_vblank: false
            clock: 0
            in_vblank: false
            dont_vblank: false
            vram: [0; 0x3FFF]
            oam: [0; 256]
            oam_addr: 0x00
            second_oam: []
            vram_page_0000
            vram_page_1000
            video_buffer
            background_visible: false
            sprites_visible: false
            buffered_read: 0
            sprite_zero_hit: false
            sprite_overflow: false
            debug: false
            rendering_enabled: false
            even_frame_flag: true
            horizontal_pixel: 0
            vertical_pixel: 0
            mirroring

            // internal PPU registers
            v: 0
            t: 0
            x: 0
            w: 0

            color_palette: [
                    rgb(101 101 101)
                    rgb(0    45 105)
                    rgb(19   31 127)
                    rgb(69   19 124)
                    rgb(96   11  98)
                    rgb(115  10  55)
                    rgb(113  15   7)
                    rgb(90   26   0)
                    rgb(52   40   0)
                    rgb(11   52   0)
                    rgb(0   60    0)    
                    rgb(0   61   16)    
                    rgb(0   56   64)
                    rgb(0    0    0)
                    rgb(0    0    0)
                    rgb(0    0    0)
                    rgb(174 174 174)
                    rgb(15   99 179)
                    rgb(64   81 208)
                    rgb(120  65 204)
                    rgb(167  54 169)
                    rgb(192  52 112)
                    rgb(189  60  48)
                    rgb(159  74   0)
                    rgb(109  92   0)
                    rgb(54  109   0)
                    rgb(7   119   4)
                    rgb(0   121  61)
                    rgb(0   114 125)
                    rgb(0     0   0)
                    rgb(0     0   0)
                    rgb(0     0   0)
                    rgb(254 254 255)
                    rgb(93  179 255)
                    rgb(143 161 255)
                    rgb(200 144 255)
                    rgb(247 133 250)
                    rgb(255 131 192)
                    rgb(255 139 127)
                    rgb(239 154  73)
                    rgb(189 172  44)
                    rgb(133 188  47)
                    rgb(85  199  83)    
                    rgb(60  201 140)    
                    rgb(62  194 205)
                    rgb(78   78  78)
                    rgb(0     0   0)
                    rgb(0     0   0)
                    rgb(254 254 255)
                    rgb(188 223 255)
                    rgb(209 216 255)
                    rgb(232 209 255)
                    rgb(251 205 253)
                    rgb(255 204 229)
                    rgb(255 207 202)
                    rgb(248 213 180)
                    rgb(228 220 168)
                    rgb(204 227 169)
                    rgb(185 232 184)    
                    rgb(174 232 208)    
                    rgb(175 229 234)
                    rgb(182 182 182)
                    rgb(0    0    0)
                    rgb(0    0    0)
                ]   
        )
    }

    public function tick(mut this, cycles: u64) throws {
        for x in (.clock)..(.clock + cycles) {
            // Where are we on the screen
            .horizontal_pixel = .clock % 341
            .vertical_pixel = .clock / 341

            .render_pixel()
            .clock += 1

            // 257-320 = sprite tile loading interval
            if (.horizontal_pixel >= 257) and (.horizontal_pixel <= 320) and ((.vertical_pixel >= 0) and (.vertical_pixel <= 239)) {
                // .oam_addr = 0x00
                .second_oam = .find_sprites(scanline: (.vertical_pixel + 1) as! u8)
            }
            if (.vertical_pixel == 241) and (.horizontal_pixel == 0) {
                .dont_vblank = false
            }
            // 240 is the post-render line, vblank is set in 241
            if (.vertical_pixel == 241) and (.horizontal_pixel == 1){
                if not .dont_vblank { .in_vblank = true }
            }
            if (.vertical_pixel == 241) and (.horizontal_pixel == 3) {
                .dont_vblank = false
            }
            // 261 is the pre-render line
            if (.vertical_pixel == 261) and (.horizontal_pixel == 1){
                .in_vblank = false
                .sprite_zero_hit = false
                .sprite_overflow = false
            }
            // Coarse X
            // if (.rendering_enabled) and (.horizontal_pixel % 8 == 0) and ((.horizontal_pixel <= 256) or (.horizontal_pixel > 328)) {
            //    .v += 1
            // }
            if (.horizontal_pixel == 339) and (.vertical_pixel == 261) and (.rendering_enabled) and (.even_frame_flag == false) { .clock = 0 }
            if (.horizontal_pixel == 340) and (.vertical_pixel == 261) { .clock = 0 }
            
            .even_frame_flag = not .even_frame_flag
        }
    }

    function read_vram(this, anon addr: u16) -> u8 {
        mut address = addr
        if .mirroring is Horizontal {
            address = address | 0x400
        }
        if .mirroring is Vertical {
            address = address | 0x800
        }
        return .vram[address]
    }

    function render_bg_pixel(mut this) throws -> bool {
        let scroll_x = (.v & 0x1f) * 8 + .x as! u16
        let scroll_y = ((.v >> 5) & 0x1f) * 8 + (.v >> 12)

        mut virtual_horizontal_pixel = .horizontal_pixel + scroll_x as! u64
        mut virtual_vertical_pixel = scroll_y as! u64

        let base_table_select = (.v >> 10) & 0x3

        mut base_table_address: u16 = match base_table_select {
            0 => 0x2000
            1 => 0x2400
            2 => 0x2800
            3 => 0x2c00
            else => {abort()}
        }

        if virtual_horizontal_pixel >= 256 {
            // FIXME: we're assuming vertical mirroring
            base_table_address ^= 0x400
            virtual_horizontal_pixel -= 256
        }

        if virtual_vertical_pixel >= 240 {
            base_table_address ^= 0x800
            virtual_vertical_pixel -= 240
        }

        // Which tile
        let vertical_tile: u16 = virtual_vertical_pixel / 8
        let horizontal_tile: u16 = virtual_horizontal_pixel / 8

        // Fetch nametable entry
        let nametable_entry = .read_vram(base_table_address + vertical_tile * 32 + horizontal_tile)
        // let nametable_entry = .vram[.base_table_address - 0x2000 + vertical_tile * 32 + horizontal_tile]
        
        let vertical_attr = vertical_tile / 4
        let horizontal_attr = horizontal_tile / 4

        // 0000
        // ^^^^  
        // | ||
        // | | plane 0
        // | plane 1
        // attr (2 bits)

        let attr = .read_vram(base_table_address + 0x3c0 + vertical_attr * 8 + horizontal_attr)

        let horizontal_box_pos = (horizontal_tile % 4) / 2
        let vertical_box_pos = (vertical_tile % 4) / 2

        let color_bits = (attr >> ((horizontal_box_pos * 2) + (vertical_box_pos * 4))) & 0x3

        let first_plane_byte = match .background_table_address {
            0000 => .vram_page_0000[nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8]
            else => .vram_page_1000[nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8]
        }
        let second_plane_byte = match .background_table_address {
            0000 => .vram_page_0000[nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8 + 8]
            else => .vram_page_1000[nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8 + 8]
        }

        let first_plane_bit = first_plane_byte >> (7 - virtual_horizontal_pixel % 8) & 0x1
        let second_plane_bit = second_plane_byte >> (7 - virtual_horizontal_pixel % 8) & 0x1

        let palette_entry = first_plane_bit + (second_plane_bit * 2) + (color_bits * 4)

        if (first_plane_bit == 0) and (second_plane_bit == 0) {
            let rgb = .look_up_palette_entry_bg(palette_entry: 0)
            .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb
            return false
        } else {
            let rgb = .look_up_palette_entry_bg(palette_entry)
            .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb
            return true
        }
    }

    function render_sprite_pixel(mut this, horizontal_pixel: u8, vertical_pixel: u8, bg_set: bool) throws {
        for sprite in .second_oam.iterator() {
            let (valid, entry) = sprite.get_sprite_pixel(x: horizontal_pixel)

            if not valid {
                continue
            }

            let transparent = (entry & 0x3) == 0
            
            // TODO: handle 8x16 sprites
            if not transparent {
        
                if not sprite.bg_sprite or not bg_set {
                    let rgb = .look_up_palette_entry_sprite(palette_entry: entry)
                    .video_buffer[vertical_pixel as! u16 * 256u16 + horizontal_pixel as! u16] = rgb
                }
                
                // Sprite zero can be hit from the background too!
                .sprite_zero_hit = (not .sprite_zero_hit) and sprite.sprite_zero 
            }
        }

    }

    function coarse_x_increment(mut this) {
        // if ((v & 0x001F) == 31) // if coarse X == 31
        //     v &= ~0x001F          // coarse X = 0
        //     v ^= 0x0400           // switch horizontal nametable
        // else
        //     v += 1                // increment coarse X

        if (.v & 0x001f) == 31 {
            .v &= ~0x001fu16
            .v ^= 0x400
        } else {
            .v += 1
        }
    }

    function y_increment(mut this) {
        // if ((v & 0x7000) != 0x7000)        // if fine Y < 7
        //   v += 0x1000                      // increment fine Y
        // else
        //   v &= ~0x7000                     // fine Y = 0
        //   int y = (v & 0x03E0) >> 5        // let y = coarse Y
        //   if (y == 29)
        //     y = 0                          // coarse Y = 0
        //     v ^= 0x0800                    // switch vertical nametable
        //   else if (y == 31)
        //     y = 0                          // coarse Y = 0, nametable not switched
        //   else
        //     y += 1                         // increment coarse Y
        //   v = (v & ~0x03E0) | (y << 5)     // put coarse Y back into v

        if (.v & 0x7000) != 0x7000 {
            .v += 0x1000
        } else {
            .v &= ~0x7000u16
            mut y = (.v & 0x3e0) >> 5
            if y == 29 {
                y = 0
                .v ^= 0x800
            } else if y == 31 {
                y = 0
            } else {
                y += 1
            }
            .v = (.v & ~0x03e0u16) | (y << 5)
        }
    }

    function find_sprites(mut this, scanline: u8) throws -> [Sprite]  {
        mut result: [Sprite] = []
        mut sprite_count = 0
        let sprite_table = match .sprite_table_address {
                    0000 => .vram_page_0000
                    else => .vram_page_1000
                }   
        for sprite in (0u8..63u8).inclusive() {
            let sprite_addr = sprite * 4u8
            let sprite_y = .oam[sprite_addr]
            let sprite_x = .oam[sprite_addr + 3]
	        
            if scanline >= sprite_y and scanline < (sprite_y + 8)  {
                if sprite_count >= 8 {
                    //println("Sprite overflow, {} entries in second OAM", result.size())
                    // TODO: properly implement the sprite overflow bug
                    .sprite_overflow = true
                    break
                }
                let sprite_attr = .oam[sprite_addr + 2]
                let vflip = (sprite_attr & 0x80) == 0x80
                let tile_row = match vflip {
                    false => (scanline - sprite_y)
                    else => 7 - (scanline - sprite_y)
                }
                //let sprite_index = (tile_row & 0x7) | ((sprite_x & 0xf) << 4) | ((sprite_y & 0xf) << 8)
                let sprite_index = .oam[sprite_addr + 1] as! u64 * 0x10 + tile_row as! u64
                let first_plane = sprite_table[sprite_index]
                let second_plane = sprite_table[sprite_index + 8]

                mut mask = [0u8; 8]
                for i in 0..8u8 {
                    mask[i] = ((first_plane >> i) & 0x1) | (((second_plane >> i & 0x1) << 1)) | ((sprite_attr & 0x3) << 2)
                }

                result.push(Sprite(
                    hflip: (sprite_attr & 0x40) == 0x40
                    mask: mask
                    bg_sprite: (sprite_attr & 0x20) == 0x20
                    sprite_x: sprite_x
                    sprite_zero: sprite == 0
                ))
                sprite_count += 1
            }
        }
        return result
    }


    function render_pixel(mut this) throws {
        // BACKGROUND
        //println("Hpx: {}, Vpx: {}", horizontal_pixel, vertical_pixel)
        let visible_row = (.vertical_pixel < 240) or (.vertical_pixel == 261)

        if .horizontal_pixel == 256 and visible_row and .rendering_enabled {
            .y_increment()
        }

        if .horizontal_pixel == 257 and visible_row and .rendering_enabled {
            let abcdef = .t & 0x41f
            .v = .v & 0x7be0
            .v = .v | abcdef
        }

        if (.horizontal_pixel >= 280) and (.horizontal_pixel <= 304) and (.vertical_pixel == 261) and .rendering_enabled {
            // GHIA.BC DEF.....
            let ghiabcdef = .t & 0x7be0
            .v = .v & 0x41f
            .v = .v | ghiabcdef
        }

        guard .horizontal_pixel < 256 else {
            return
        }

        guard .vertical_pixel < 240 else {
            return
        }

        // if .horizontal_pixel == 0 {
        //     .second_oam = .find_sprites(scanline: .vertical_pixel as! u8)  
        // }

        mut bg_pixel_set = false
        mut sprite_zero_set = false

        //if .sprites_visible {
        //    sprite_zero_set |= .render_sprite_pixel(horizontal_pixel, vertical_pixel, is_behind: true)
        //}

        // FIXME: when we add support for sprites remove this
        if .background_visible {
            bg_pixel_set = .render_bg_pixel()
        }

        if .sprites_visible {
            .render_sprite_pixel(horizontal_pixel: .horizontal_pixel as! u8, vertical_pixel: .vertical_pixel as! u8, bg_set: bg_pixel_set)
        }

        if not .background_visible and not .sprites_visible {
            let rgb = .look_up_palette_entry_bg(palette_entry: 0)
            .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb            
        }

        // if rgb.red != 0 and rgb.blue != 0 and rgb.green != 0 {
        //     println("{}, {} is {} {:0>2x}", horizontal_pixel, vertical_pixel, rgb, nametable_entry)
        // }
        // print("{:0>2x}", nametable_entry)
    }

    function look_up_palette_entry_bg(mut this, palette_entry: u8) -> RGB {
        guard palette_entry < 16 else {
            println("ERROR: incorrect palette entry: {}", palette_entry)
            //return RGB(red: 0, green: 0, blue: 0)
            abort()
        }

        let bg_palette = .vram[0x3f00 + palette_entry as! u64]

        return .convert_palette_to_rgb(bg_palette)
    }

    function look_up_palette_entry_sprite(mut this, palette_entry: u8) -> RGB {
        guard palette_entry < 16 else {
            println("ERROR: incorrect palette entry: {}", palette_entry)
            //return RGB(red: 0, green: 0, blue: 0)
            abort()
        }

        match palette_entry {
            0 => { return .convert_palette_to_rgb(.vram[0x3f00]) }
            0x4 => { return .convert_palette_to_rgb(.vram[0x3f04]) }
            0x8 => { return .convert_palette_to_rgb(.vram[0x3f08]) }
            0xc => { return .convert_palette_to_rgb(.vram[0x3f0c]) }
            else => { return .convert_palette_to_rgb(.vram[0x3f10 + (palette_entry as! u64)]) }
        }
    }

    function ppu_ctrl(mut this, value: u8) {

        // 7  bit  0
        // ---- ----
        // VPHB SINN
        // |||| ||||
        // |||| ||++- Base nametable address
        // |||| ||    (0 = $2000; 1 = $2400; 2 = $2800; 3 = $2C00)
        // |||| |+--- VRAM address increment per CPU read/write of PPUDATA
        // |||| |     (0: add 1, going across; 1: add 32, going down)
        // |||| +---- Sprite pattern table address for 8x8 sprites
        // ||||       (0: $0000; 1: $1000; ignored in 8x16 mode)
        // |||+------ Background pattern table address (0: $0000; 1: $1000)
        // ||+------- Sprite size (0: 8x8 pixels; 1: 8x16 pixels – see PPU OAM#Byte 1)
        // |+-------- PPU master/slave select
        // |          (0: read backdrop from EXT pins; 1: output color on EXT pins)
        // +--------- Generate an NMI at the start of the
        //            vertical blanking interval (0: off; 1: on)


        let gh = value & 0x3

        .t = .t & 0xf3ff
        .t = .t | ((gh as! u16) << 10)

        if (value & 0x4) == 0x4 {
            .vram_address_increment = 32
        } else {
            .vram_address_increment = 1
        }
        if (value & 0x8) == 0x8 {
            .sprite_table_address = 0x1000
        } else {
            .sprite_table_address = 0x0000
        }
        if (value & 0x10) == 0x10 {
            .background_table_address = 0x1000
        } else {
            .background_table_address = 0x0000
        }
        if (value & 0x20) == 0x20 {
            .sprite_size_8x8 = false
        } else {
            .sprite_size_8x8 = true
        }
        if (value & 0x80) == 0x80 {
            .nmi_on_vblank = true
        } else {
            .nmi_on_vblank = false
        }

        // println("base_table_address: {:0>4x} (vtick: {})", .base_table_address, .clock)
        // println("vram_address_increment: {}", .vram_address_increment)
        // println("sprite_table_address: {:0>4x}", .sprite_table_address)
        // println("background_table_address: {:0>4x}", .background_table_address)
        // println("sprite size 8x8: {}", .sprite_size_8x8)
        // println("nmi_on_vblank: {}", .nmi_on_vblank)
    }

    function ppu_mask(mut this, value: u8) {
        // TODO: implement

        // 7  bit  0
        // ---- ----
        // BGRs bMmG
        // |||| ||||
        // |||| |||+- Greyscale (0: normal color, 1: produce a greyscale display)
        // |||| ||+-- 1: Show background in leftmost 8 pixels of screen, 0: Hide
        // |||| |+--- 1: Show sprites in leftmost 8 pixels of screen, 0: Hide
        // |||| +---- 1: Show background
        // |||+------ 1: Show sprites
        // ||+------- Emphasize red (green on PAL/Dendy)
        // |+-------- Emphasize green (red on PAL/Dendy)
        // +--------- Emphasize blue

        let PPU_GREYSCALE_MASK = 0b00000001 as! u8
        let PPU_LEFT_BACKGROUND_MASK = 0b00000010 as! u8
        let PPU_LEFT_SPRITE_MASK = 0b00000100 as! u8
        let PPU_BACKGROUND_MASK = 0b00001000 as! u8
        let PPU_SPRITE_MASK = 0b00010000 as! u8
        let PPU_RED_EMPHASIZE_MASK = 0b00100000 as! u8
        let PPU_GREEN_EMPHASIZE_MASK = 0b01000000 as! u8
        let PPU_BLUE_EMPHASIZE_MASK = 0b10000000 as! u8

        // println("PPU mask: {:0>2x}", value)

        // TODO: Bool casts aren't working in Jakt, but the below should be a 
        // quick way to set a flag once they are
        //.sprites_visible = value << 6 >>> 7 as! bool
        if (value & PPU_SPRITE_MASK) == PPU_SPRITE_MASK {
            .sprites_visible = true
        } else {
            .sprites_visible = false
        }



        if (value & PPU_BACKGROUND_MASK) == PPU_BACKGROUND_MASK {
            .background_visible = true
        } else {
            .background_visible = false
        }

        let render_bytes = (value << 3) >>> 6
        if render_bytes == 0b00 {
            .rendering_enabled = false
        } else {
            .rendering_enabled = true
        }
    }

    function ppu_scroll(mut this, value: u8) {
        // println("PPU scroll: {:0>2x} {}", value, .scroll_toggle)

        if .w == 0 {
            let abcde = value >> 3
            .t = .t & 0xffe0
            .t = .t | abcde
            .x = value & 0x7
            .w = 1
        } else {
            let abcde = value >> 3
            let fgh = value & 0x7
            .t = .t & 0xc1f
            .t = .t | ((fgh as! u16) << 12)
            .t = .t | ((abcde as! u16) << 5)
            .w = 0
        }
    }

    function ppu_addr(mut this, value: u8) {
        if .w == 0 {
            let cdefgh = value & 0x3f
            .t = .t & 0xff
            .t = .t | ((cdefgh as! u16) << 8)
            .w = 1
        } else {
            .t = .t & 0xff00
            .t = .t | (value as! u16)
            .v = .t
            .w = 0
        }
    }

    function ppu_data_write(mut this, value: u8) {
        // TODO: add support for various mirroring

        // Outside of rendering, reads from or writes to $2007 will add either 1 or 32 to v depending on the VRAM increment bit set via $2000. 
        // During rendering (on the pre-render line and the visible lines 0-239, provided either background or sprite rendering is enabled), it 
        // will update v in an odd way, triggering a coarse X increment and a Y increment simultaneously (with normal wrapping behavior). 
        // Internally, this is caused by the carry inputs to various sections of v being set up for rendering, and the $2007 access triggering a 
        // "load next value" signal for all of v (when not rendering, the carry inputs are set up to linearly increment v by either 1 or 32). 
        // This behavior is not affected by the status of the increment bit. The Young Indiana Jones Chronicles uses this for some effects to 
        // adjust the Y scroll during rendering, and also Burai Fighter (U) to draw the scorebar. If the $2007 access happens to coincide with a 
        // standard VRAM address increment (either horizontal or vertical), it will presumably not double-increment the relevant counter.

        // Address range 	Size 	Description
        // $0000-$0FFF 	$1000 	Pattern table 0
        // $1000-$1FFF 	$1000 	Pattern table 1
        // $2000-$23FF 	$0400 	Nametable 0
        // $2400-$27FF 	$0400 	Nametable 1
        // $2800-$2BFF 	$0400 	Nametable 2
        // $2C00-$2FFF 	$0400 	Nametable 3
        // $3000-$3EFF 	$0F00 	Mirrors of $2000-$2EFF
        // $3F00-$3F1F 	$0020 	Palette RAM indexes
        // $3F20-$3FFF 	$00E0 	Mirrors of $3F00-$3F1F 

        // println("PPU data write rendering: {}, vblank: ", .rendering_enabled, .in_vblank)
        //  if .rendering_enabled or .in_vblank {

        mut address = .v
        if .mirroring is Horizontal {
            address = address | 0x400
        }
        if .mirroring is Vertical {
            address = address | 0x800
        }

        // println("PPU write: {:0>4x}", address)

        if address >= 0x4000 {
            println("bad ppu addr")
            abort()
        }

        .vram[address] = value
        if (address >= 0x2000) and (address <= 0x2eff) {
            .vram[address + 0x1000] = value
        }
        if (address >= 0x3000) and (address <= 0x3eff) {   
            .vram[address - 0x1000] = value
        }
        if (address >= 0x3f00) and (address <= 0x3fff) {
            let sub_address = (address - 0x3f00) % 0x20
            .vram[0x3f00 + sub_address] = value
            .vram[0x3f00 + 0x20 as! u16 + sub_address] = value
            .vram[0x3f00 + (0x20 * 2) as! u16 + sub_address] = value
            .vram[0x3f00 + (0x20 * 3) as! u16 + sub_address] = value
            .vram[0x3f00 + (0x20 * 4) as! u16 + sub_address] = value
            .vram[0x3f00 + (0x20 * 5) as! u16 + sub_address] = value
            .vram[0x3f00 + (0x20 * 6) as! u16 + sub_address] = value
        }
        match address {
            0x3f00 => { .vram[0x3f10] = value }
            0x3f04 => { .vram[0x3f14] = value }
            0x3f08 => { .vram[0x3f18] = value }
            0x3f0C => { .vram[0x3f1C] = value }
            0x3f10 => { .vram[0x3f00] = value }
            0x3f14 => { .vram[0x3f04] = value }
            0x3f18 => { .vram[0x3f08] = value }
            0x3f1C => { .vram[0x3f0C] = value }
            else => {}
        }
        .increment_v()
    }

    function increment_v(mut this) {
        if (.background_visible or .sprites_visible) and (.vertical_pixel < 240 or .vertical_pixel == 261) {
            .coarse_x_increment()
            .y_increment()
        } else {
            .v += .vram_address_increment
        }
    }

    function ppu_data_read(mut this) -> u8 {
        mut output = 0u8
//        println("PPU read: {:0>4x}", .v)

        if .v <= 0x3eff {
            mut value: u8 = 0
            if .v < 0x1000 {
                value = .vram_page_0000[.v]
            } else if .v < 0x2000 {
                value = .vram_page_1000[.v - 0x1000]
            } else if (.v >= 0x2000) and (.v <= 0x2fff){
                value = .vram[.v]
            }
            .increment_v()
            output = .buffered_read
            .buffered_read = value
        } else {
            let value = .vram[.v]
            .increment_v()
            output = value
        }
        return output
    }

    function ppu_status(mut this) -> u8 {
        mut status = 0
        if .in_vblank {
            // println("Reading vblank status")
            status |= 0x80
        }
        if .sprite_zero_hit {
            status |= 0x40
        }

        .w = 0
        if (.vertical_pixel == 241) and (.horizontal_pixel >= 1 or .horizontal_pixel <= 3){
            .dont_vblank = true
        }
        .in_vblank = false
        return status
    }

    public function write_ppu_addr(mut this, address: u16, value: u8) {
        // PPU registers are mirrored all the way to 3FFF, try to handle that
        let mirrored_address = (address % 0x8) + 0x2000
        match mirrored_address {
            0x2000 => .ppu_ctrl(value)
            0x2001 => .ppu_mask(value)
            0x2003 => .oam_addr_write(value) //From NESDEV wiki - most games write $00 here and use OAMDMA
            //0x2004 => .oam_data(value) // TODO
            0x2005 => .ppu_scroll(value) // Write twice
            0x2006 => .ppu_addr(value) // Write twice
            0x2007 => .ppu_data_write(value)
            //0x4014 => .oam_dma(value) // TODO?
            else => {}
        }
    }

    public function oam_addr_write(mut this, value: u8) {
        .oam_addr = value
    }

    public function read_ppu_addr(mut this, address: u16) -> u8 {
        let mirrored_address = (address % 0x8) + 0x2000
        return match mirrored_address {
            0x2002 => .ppu_status()
            //0x2004 => .oam_data() // TODO?
            0x2007 => .ppu_data_read()
            else => 0
        }
    }

    function convert_palette_to_rgb(this, anon value: u8) -> RGB {
        if value > 63 {
            eprintln("ERROR: incorrect palette for rgb: {}", value)
            abort()
        }
        return .color_palette[value]
    }

}

function rgb(anon red: u8, anon green: u8, anon blue: u8) throws -> RGB {
    return RGB(red, green, blue)
}
