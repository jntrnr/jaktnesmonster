class RGB {
    public red: u8
    public green: u8
    public blue: u8
}

class PPU {
    // base_table_address: u16
    vram_address_increment: u16
    sprite_table_address: u16
    background_table_address: u16
    sprite_size_8x8: bool
    public nmi_on_vblank: bool
    clock: u64
    public in_vblank: bool
    vram: [u8]
    // public vram_rw_addr: u16
    public oam: [u8]
    oam_addr: u8
    vram_page_0000: [u8]
    vram_page_1000: [u8]
    public video_buffer: [RGB]
    // scroll_x: u8
    // scroll_y: u8
    // scroll_toggle: bool
    background_visible: bool
    sprites_visible: bool
    buffered_read: u8
    sprite_zero_hit: bool
    public debug: bool
    rendering_enabled: bool
    even_frame_flag: bool
    horizontal_pixel: u64
    vertical_pixel: u64

    // Internal PPU registers (from https://www.nesdev.org/wiki/PPU_scrolling)
    v: u16
    t: u16
    x: u8
    w: u8

    public function init(vram_page_0000: [u8], vram_page_1000: [u8]) throws -> PPU {
        mut video_buffer: [RGB] = []
        for _ in 0..(256*240) {
            video_buffer.push(rgb(0, 0, 0))
        }
        return PPU(
            vram_address_increment: 1
            sprite_table_address: 0x0000
            background_table_address: 0x0000
            sprite_size_8x8: true
            nmi_on_vblank: false
            clock: 0
            in_vblank: false
            vram: [0; 0x3FFF]
            oam: [0; 256]
            oam_addr: 0x00
            vram_page_0000
            vram_page_1000
            video_buffer
            background_visible: false
            sprites_visible: false
            buffered_read: 0
            sprite_zero_hit: false
            debug: false
            rendering_enabled: false
            even_frame_flag: true
            horizontal_pixel: 0
            vertical_pixel: 0

            // internal PPU registers
            v: 0
            t: 0
            x: 0
            w: 0
        )
    }

    public function tick(mut this, cycles: u64) throws {
        

        for x in (.clock)..(.clock + cycles) {
            // Where are we on the screen
            .horizontal_pixel = .clock % 341
            .vertical_pixel = .clock / 341

            .render_pixel()
            .clock += 1

            // 257-320 = sprite tile loading interval
            if (.horizontal_pixel >= 257) and (.horizontal_pixel <= 320) and (((.vertical_pixel >= 1) and (.vertical_pixel <= 239)) or (.vertical_pixel == 261)) {
                .oam_addr = 0x00
            }
            // 240 is the post-render line, vblank is set in 241
            if (.vertical_pixel == 241) and (.horizontal_pixel == 1){
                .in_vblank = true
            }
            // 261 is the pre-render line
            if (.vertical_pixel == 261) and (.horizontal_pixel == 1){
                .in_vblank = false
                .sprite_zero_hit = false
                // TODO: Add support for sprite overflow
                // .sprite_overflow = false
            }
            // Coarse X
            // if (.rendering_enabled) and (.horizontal_pixel % 8 == 0) and ((.horizontal_pixel <= 256) or (.horizontal_pixel > 328)) {
            //    .v += 1
            // }
            if (.horizontal_pixel == 340) and (.vertical_pixel == 261) and (.rendering_enabled) and (.even_frame_flag == false) { .clock = 0 }
            if (.horizontal_pixel == 340) and (.vertical_pixel == 261) { .clock = 0 }
                .even_frame_flag != .even_frame_flag
        }
    }

    function read_vram(this, anon addr: u16) -> u8 {
        return .vram[addr]
    }

    function render_bg_pixel(mut this) throws -> bool {
        let scroll_x = (.v & 0x1f) * 8 + .x as! u16
        let scroll_y = ((.v >> 5) & 0x1f) * 8 + (.v >> 12)

        mut virtual_horizontal_pixel = .horizontal_pixel + scroll_x as! u64
        mut virtual_vertical_pixel = .vertical_pixel + scroll_y as! u64

        let base_table_select = (.v >> 10) & 0x3

        mut base_table_address: u16 = match base_table_select {
            0 => 0x2000
            1 => 0x2400
            2 => 0x2800
            3 => 0x2c00
            else => {abort()}
        }

        if virtual_horizontal_pixel >= 256 {
            // FIXME: we're assuming vertical mirroring
            base_table_address ^= 0x400
            virtual_horizontal_pixel -= 256
        }

        if virtual_vertical_pixel >= 240 {
            base_table_address ^= 0x800
            virtual_vertical_pixel -= 240
        }

        // Which tile
        let vertical_tile: u16 = virtual_vertical_pixel / 8
        let horizontal_tile: u16 = virtual_horizontal_pixel / 8

        // Fetch nametable entry
        let nametable_entry = .read_vram(base_table_address + vertical_tile * 32 + horizontal_tile)
        // let nametable_entry = .vram[.base_table_address - 0x2000 + vertical_tile * 32 + horizontal_tile]
        
        let vertical_attr = vertical_tile / 4
        let horizontal_attr = horizontal_tile / 4

        // 0000
        // ^^^^  
        // | ||
        // | | plane 0
        // | plane 1
        // attr (2 bits)

        let attr = .read_vram(base_table_address + 0x3c0 + vertical_attr * 8 + horizontal_attr)

        let horizontal_box_pos = (horizontal_tile % 4) / 2
        let vertical_box_pos = (vertical_tile % 4) / 2

        let color_bits = (attr >> ((horizontal_box_pos * 2) + (vertical_box_pos * 4))) & 0x3

        let first_plane_byte = match .background_table_address {
            0000 => .vram_page_0000[nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8]
            else => .vram_page_1000[nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8]
        }
        let second_plane_byte = match .background_table_address {
            0000 => .vram_page_0000[nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8 + 8]
            else => .vram_page_1000[nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8 + 8]
        }

        let first_plane_bit = first_plane_byte >> (7 - virtual_horizontal_pixel % 8) & 0x1
        let second_plane_bit = second_plane_byte >> (7 - virtual_horizontal_pixel % 8) & 0x1

        let palette_entry = first_plane_bit + (second_plane_bit * 2) + (color_bits * 4)

        if (first_plane_bit == 0) and (second_plane_bit == 0) {
            let rgb = .look_up_palette_entry_bg(palette_entry: 0)
            .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb
            return false
        } else {
            let rgb = .look_up_palette_entry_bg(palette_entry)
            .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb
            return true
        }
    }

    function render_sprite_pixel(mut this, is_behind: bool) throws -> bool {
        for sprite in 63..-1 {
            let sprite_attr = .oam[sprite * 4 + 2]

            if (sprite_attr & 0x20) == 0x20 and not is_behind {
                continue
            }

            if (sprite_attr & 0x20) == 0x0 and is_behind {
                continue
            }

            let sprite_y = .oam[sprite * 4] as! u64

            let sprite_x = .oam[sprite * 4 + 3] as! u64

            // TODO: handle 8x16 sprites
            if (.vertical_pixel >= sprite_y) and (.vertical_pixel < (sprite_y + 8)) and (.horizontal_pixel >= sprite_x) and (.horizontal_pixel < (sprite_x + 8)) {
                mut sprite_row = (.vertical_pixel - sprite_y) as! u64
                mut sprite_col = (.horizontal_pixel - sprite_x) as! u64
                                
                let sprite_index = .oam[sprite * 4 + 1]

                if (sprite_attr & 0x80) == 0x80 {
                    sprite_row = 7 - sprite_row
                }

                if (sprite_attr & 0x40) == 0x40 {
                    sprite_col = 7 - sprite_col
                }

                let first_plane_byte = match .sprite_table_address {
                    0000 => .vram_page_0000[sprite_index as! u64 * 0x10 + sprite_row]
                    else => .vram_page_1000[sprite_index as! u64 * 0x10 + sprite_row]
                }
                let second_plane_byte = match .sprite_table_address {
                    0000 => .vram_page_0000[sprite_index as! u64 * 0x10 + sprite_row + 8]
                    else => .vram_page_1000[sprite_index as! u64 * 0x10 + sprite_row + 8]
                }

                let first_plane_bit = first_plane_byte >> (7 - sprite_col) & 0x1
                let second_plane_bit = second_plane_byte >> (7 - sprite_col) & 0x1

                let color_bits = sprite_attr & 0x3

                let palette_entry = first_plane_bit + (second_plane_bit * 2) + (color_bits * 4)

                if (first_plane_bit == 0) and (second_plane_bit == 0) {
                    if is_behind {
                        let rgb = .look_up_palette_entry_sprite(palette_entry: 0)
                        .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb
                    }
                } else {
                    let rgb = .look_up_palette_entry_sprite(palette_entry)
                    .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb

                    if not .sprite_zero_hit and sprite == 0 {
                        return true
                    }
                }
            }
        }

        return false
    }

    function coarse_x_increment(mut this) {
        // if ((v & 0x001F) == 31) // if coarse X == 31
        //     v &= ~0x001F          // coarse X = 0
        //     v ^= 0x0400           // switch horizontal nametable
        // else
        //     v += 1                // increment coarse X

        if (.v & 0x001f) == 31 {
            .v &= ~0x001fu16
            .v ^= 0x400
        } else {
            .v += 1
        }
    }

    function y_increment(mut this) {
        // if ((v & 0x7000) != 0x7000)        // if fine Y < 7
        //   v += 0x1000                      // increment fine Y
        // else
        //   v &= ~0x7000                     // fine Y = 0
        //   int y = (v & 0x03E0) >> 5        // let y = coarse Y
        //   if (y == 29)
        //     y = 0                          // coarse Y = 0
        //     v ^= 0x0800                    // switch vertical nametable
        //   else if (y == 31)
        //     y = 0                          // coarse Y = 0, nametable not switched
        //   else
        //     y += 1                         // increment coarse Y
        //   v = (v & ~0x03E0) | (y << 5)     // put coarse Y back into v

        if (.v & 0x7000) != 0x7000 {
            .v += 0x1000
        } else {
            .v &= ~0x7000u16
            mut y = (.v & 0x3e0) >> 5
            if y == 29 {
                y = 0
                .v ^= 0x800
            } else if y == 31 {
                y = 0
            } else {
                y += 1
            }
            .v = (.v & ~0x03e0u16) | (y << 5)
        }
    }
    function render_pixel(mut this) throws {
        // BACKGROUND
        //println("Hpx: {}, Vpx: {}", horizontal_pixel, vertical_pixel)
        if .horizontal_pixel == 256 and .rendering_enabled {
            .y_increment()
        }

        if .horizontal_pixel == 257 and .rendering_enabled {
            let abcdef = .t & 0x41f
            .v = .v & 0xbe0
            .v = .v | abcdef
        }

        if (.horizontal_pixel >= 280) and (.horizontal_pixel <= 304) and (.vertical_pixel == 262) and .rendering_enabled {
            // GHIA.BC DEF.....
            let ghiabcdef = .t & 0x7be0
            .v = .v & 0x41f
            .v = .v | ghiabcdef
        }

        guard .horizontal_pixel < 256 else {
            return
        }

        guard .vertical_pixel < 240 else {
            return
        }

        mut bg_pixel_set = false
        mut sprite_zero_set = false

        if .sprites_visible {
            sprite_zero_set |= .render_sprite_pixel(is_behind: true)
        }

        // FIXME: when we add support for sprites remove this
        if .background_visible {
            bg_pixel_set = .render_bg_pixel()
        }

        if .sprites_visible {
            sprite_zero_set |= .render_sprite_pixel(is_behind: false)
        }

        if bg_pixel_set and sprite_zero_set {
            .sprite_zero_hit = true
        }

        // if rgb.red != 0 and rgb.blue != 0 and rgb.green != 0 {
        //     println("{}, {} is {} {:0>2x}", horizontal_pixel, vertical_pixel, rgb, nametable_entry)
        // }
        // print("{:0>2x}", nametable_entry)
    }

    function look_up_palette_entry_bg(mut this, palette_entry: u8) throws -> RGB {
        guard palette_entry < 16 else {
            println(format("ERROR: incorrect palette entry: {}", palette_entry))
            return RGB(red: 0, green: 0, blue: 0)
        }

        let bg_palette = .vram[0x3f00 + palette_entry as! u64]

        return convert_palette_to_rgb(bg_palette)
    }

    function look_up_palette_entry_sprite(mut this, palette_entry: u8) throws -> RGB {
        guard palette_entry < 16 else {
            println(format("ERROR: incorrect palette entry: {}", palette_entry))
            return RGB(red: 0, green: 0, blue: 0)
        }

        match palette_entry {
            0 => { return convert_palette_to_rgb(.vram[0x3f00]) }
            0x4 => { return convert_palette_to_rgb(.vram[0x3f04]) }
            0x8 => { return convert_palette_to_rgb(.vram[0x3f08]) }
            0xc => { return convert_palette_to_rgb(.vram[0x3f0c]) }
            else => { return convert_palette_to_rgb(.vram[0x3f10 + (palette_entry as! u64)]) }
        }
    }

    function ppu_ctrl(mut this, value: u8) {

        // 7  bit  0
        // ---- ----
        // VPHB SINN
        // |||| ||||
        // |||| ||++- Base nametable address
        // |||| ||    (0 = $2000; 1 = $2400; 2 = $2800; 3 = $2C00)
        // |||| |+--- VRAM address increment per CPU read/write of PPUDATA
        // |||| |     (0: add 1, going across; 1: add 32, going down)
        // |||| +---- Sprite pattern table address for 8x8 sprites
        // ||||       (0: $0000; 1: $1000; ignored in 8x16 mode)
        // |||+------ Background pattern table address (0: $0000; 1: $1000)
        // ||+------- Sprite size (0: 8x8 pixels; 1: 8x16 pixels – see PPU OAM#Byte 1)
        // |+-------- PPU master/slave select
        // |          (0: read backdrop from EXT pins; 1: output color on EXT pins)
        // +--------- Generate an NMI at the start of the
        //            vertical blanking interval (0: off; 1: on)


        let gh = value & 0x3

        .t = .t & 0xf3ff
        .t = .t | ((gh as! u16) << 10)

        if (value & 0x4) == 0x4 {
            .vram_address_increment = 32
        } else {
            .vram_address_increment = 1
        }
        if (value & 0x8) == 0x8 {
            .sprite_table_address = 0x1000
        } else {
            .sprite_table_address = 0x0000
        }
        if (value & 0x10) == 0x10 {
            .background_table_address = 0x1000
        } else {
            .background_table_address = 0x0000
        }
        if (value & 0x20) == 0x20 {
            .sprite_size_8x8 = false
        } else {
            .sprite_size_8x8 = true
        }
        if (value & 0x80) == 0x80 {
            .nmi_on_vblank = true
        } else {
            .nmi_on_vblank = false
        }

        // println("base_table_address: {:0>4x} (vtick: {})", .base_table_address, .clock)
        // println("vram_address_increment: {}", .vram_address_increment)
        // println("sprite_table_address: {:0>4x}", .sprite_table_address)
        // println("background_table_address: {:0>4x}", .background_table_address)
        // println("sprite size 8x8: {}", .sprite_size_8x8)
        // println("nmi_on_vblank: {}", .nmi_on_vblank)
    }

    function ppu_mask(mut this, value: u8) {
        // TODO: implement

        // 7  bit  0
        // ---- ----
        // BGRs bMmG
        // |||| ||||
        // |||| |||+- Greyscale (0: normal color, 1: produce a greyscale display)
        // |||| ||+-- 1: Show background in leftmost 8 pixels of screen, 0: Hide
        // |||| |+--- 1: Show sprites in leftmost 8 pixels of screen, 0: Hide
        // |||| +---- 1: Show background
        // |||+------ 1: Show sprites
        // ||+------- Emphasize red (green on PAL/Dendy)
        // |+-------- Emphasize green (red on PAL/Dendy)
        // +--------- Emphasize blue

        let PPU_GREYSCALE_MASK = 0b00000001 as! u8
        let PPU_LEFT_BACKGROUND_MASK = 0b00000010 as! u8
        let PPU_LEFT_SPRITE_MASK = 0b00000100 as! u8
        let PPU_BACKGROUND_MASK = 0b00001000 as! u8
        let PPU_SPRITE_MASK = 0b00010000 as! u8
        let PPU_RED_EMPHASIZE_MASK = 0b00100000 as! u8
        let PPU_GREEN_EMPHASIZE_MASK = 0b01000000 as! u8
        let PPU_BLUE_EMPHASIZE_MASK = 0b10000000 as! u8

        // println("PPU mask: {:0>2x}", value)

        // TODO: Bool casts aren't working in Jakt, but the below should be a 
        // quick way to set a flag once they are
        //.sprites_visible = value << 6 >>> 7 as! bool
        if (value & PPU_SPRITE_MASK) == PPU_SPRITE_MASK {
            .sprites_visible = true
        } else {
            .sprites_visible = false
        }



        if (value & PPU_BACKGROUND_MASK) == PPU_BACKGROUND_MASK {
            .background_visible = true
        } else {
            .background_visible = false
        }

        let render_bytes = (value << 3) >>> 6
        if render_bytes == 0b00 {
            .rendering_enabled = false
        } else {
            .rendering_enabled = true
        }
    }

    function ppu_scroll(mut this, value: u8) {
        // println("PPU scroll: {:0>2x} {}", value, .scroll_toggle)

        if .w == 0 {
            let abcde = value >> 3
            .t = .t & 0xffe0
            .t = .t | abcde
            .x = value & 0x7
            .w = 1
        } else {
            let abcde = value >> 3
            let fgh = value & 0x7
            .t = .t & 0xc1f
            .t = .t | ((fgh as! u16) << 12)
            .t = .t | ((abcde as! u16) << 5)
            .w = 0
        }
    }

    function ppu_addr(mut this, value: u8) {
        if .w == 0 {
            let cdefgh = value & 0x3f
            .t = .t & 0xff
            .t = .t | ((cdefgh as! u16) << 8)
            .w = 1
        } else {
            .t = .t & 0xff00
            .t = .t | (value as! u16)
            .v = .t
            .w = 0
        }
    }

    function ppu_data_write(mut this, value: u8) {
        // TODO: add support for various mirroring

        // Outside of rendering, reads from or writes to $2007 will add either 1 or 32 to v depending on the VRAM increment bit set via $2000. 
        // During rendering (on the pre-render line and the visible lines 0-239, provided either background or sprite rendering is enabled), it 
        // will update v in an odd way, triggering a coarse X increment and a Y increment simultaneously (with normal wrapping behavior). 
        // Internally, this is caused by the carry inputs to various sections of v being set up for rendering, and the $2007 access triggering a 
        // "load next value" signal for all of v (when not rendering, the carry inputs are set up to linearly increment v by either 1 or 32). 
        // This behavior is not affected by the status of the increment bit. The Young Indiana Jones Chronicles uses this for some effects to 
        // adjust the Y scroll during rendering, and also Burai Fighter (U) to draw the scorebar. If the $2007 access happens to coincide with a 
        // standard VRAM address increment (either horizontal or vertical), it will presumably not double-increment the relevant counter.

        // Address range 	Size 	Description
        // $0000-$0FFF 	$1000 	Pattern table 0
        // $1000-$1FFF 	$1000 	Pattern table 1
        // $2000-$23FF 	$0400 	Nametable 0
        // $2400-$27FF 	$0400 	Nametable 1
        // $2800-$2BFF 	$0400 	Nametable 2
        // $2C00-$2FFF 	$0400 	Nametable 3
        // $3000-$3EFF 	$0F00 	Mirrors of $2000-$2EFF
        // $3F00-$3F1F 	$0020 	Palette RAM indexes
        // $3F20-$3FFF 	$00E0 	Mirrors of $3F00-$3F1F 

        // println("PPU data write rendering: {}, vblank: ", .rendering_enabled, .in_vblank)
        //  if .rendering_enabled or .in_vblank {

  //          println("PPU write: {:0>4x}", .v)

            if .v >= 0x4000 {
                println("bad ppu addr")
                abort()
            }

            .vram[.v] = value
            if (.v >= 0x2000) and (.v <= 0x2eff) {
                .vram[.v + 0x1000] = value
            }
            if (.v >= 0x3000) and (.v <= 0x3eff) {   
                .vram[.v - 0x1000] = value
            }
            if (.v >= 0x3f00) and (.v <= 0x3fff) {
                let sub_address = (.v - 0x3f00) % 0x20
                .vram[0x3f00 + sub_address] = value
                .vram[0x3f00 + 0x20 as! u16 + sub_address] = value
                .vram[0x3f00 + (0x20 * 2) as! u16 + sub_address] = value
                .vram[0x3f00 + (0x20 * 3) as! u16 + sub_address] = value
                .vram[0x3f00 + (0x20 * 4) as! u16 + sub_address] = value
                .vram[0x3f00 + (0x20 * 5) as! u16 + sub_address] = value
                .vram[0x3f00 + (0x20 * 6) as! u16 + sub_address] = value
            }
            match .v{
                0x3f00 => { .vram[0x3f10] = value }
                0x3f04 => { .vram[0x3f14] = value }
                0x3f08 => { .vram[0x3f18] = value }
                0x3f0C => { .vram[0x3f1C] = value }
                0x3f10 => { .vram[0x3f00] = value }
                0x3f14 => { .vram[0x3f04] = value }
                0x3f18 => { .vram[0x3f08] = value }
                0x3f1C => { .vram[0x3f0C] = value }
                else => {}
            }
            .v += .vram_address_increment
    }

    function ppu_data_read(mut this) -> u8 {
        mut output = 0u8
//        println("PPU read: {:0>4x}", .v)

        if .v <= 0x3eff {
            mut value: u8 = 0
            if .v < 0x1000 {
                value = .vram_page_0000[.v]
            } else if .v < 0x2000 {
                value = .vram_page_1000[.v - 0x1000]
            } else if (.v >= 0x2000) and (.v <= 0x2fff){
                value = .vram[.v]
            }
            .v += .vram_address_increment
            output = .buffered_read
            .buffered_read = value
        } else {
                let value = .vram[.v]
                .v += .vram_address_increment
                output = value
        }
        return output
    }

    function ppu_status(mut this) -> u8 {
        mut status = 0
        if .in_vblank {
            // println("Reading vblank status")
            status |= 0x80
        }
        if .sprite_zero_hit {
            status |= 0x40
        }

        .w = 0

        .in_vblank = false
        return status
    }

    public function write_ppu_addr(mut this, address: u16, value: u8) {
        // PPU registers are mirrored all the way to 3FFF, try to handle that
        let mirrored_address = (address % 0x8) + 0x2000
        match mirrored_address {
            0x2000 => .ppu_ctrl(value)
            0x2001 => .ppu_mask(value)
            0x2003 => .oam_addr_write(value) //From NESDEV wiki - most games write $00 here and use OAMDMA
            //0x2004 => .oam_data(value) // TODO
            0x2005 => .ppu_scroll(value) // Write twice
            0x2006 => .ppu_addr(value) // Write twice
            0x2007 => .ppu_data_write(value)
            //0x4014 => .oam_dma(value) // TODO?
            else => {}
        }
    }

    public function oam_addr_write(mut this, value: u8) {
        .oam_addr = value
    }

    public function read_ppu_addr(mut this, address: u16) -> u8 {
        let mirrored_address = (address % 0x8) + 0x2000
        return match mirrored_address {
            0x2002 => .ppu_status()
            //0x2004 => .oam_data() // TODO?
            0x2007 => .ppu_data_read()
            else => 0
        }
    }
}

function rgb(anon red: u8, anon green: u8, anon blue: u8) throws -> RGB {
    return RGB(red, green, blue)
}

function convert_palette_to_rgb(anon value: u8) throws -> RGB {
    return match value {
        0x00 => rgb(101 101 101)
        0x01 => rgb(0    45 105)
        0x02 => rgb(19   31 127)
        0x03 => rgb(69   19 124)
        0x04 => rgb(96   11  98)
        0x05 => rgb(115  10  55)
        0x06 => rgb(113  15   7)
        0x07 => rgb(90   26   0)
        0x08 => rgb(52   40   0)
        0x09 => rgb(11   52   0)
        0x0a => rgb(0   60    0)    
        0x0b => rgb(0   61   16)    
        0x0c => rgb(0   56   64)
        0x0d => rgb(0    0    0)
        0x0e => rgb(0    0    0)
        0x0f => rgb(0    0    0)
        0x10 => rgb(174 174 174)
        0x11 => rgb(15   99 179)
        0x12 => rgb(64   81 208)
        0x13 => rgb(120  65 204)
        0x14 => rgb(167  54 169)
        0x15 => rgb(192  52 112)
        0x16 => rgb(189  60  48)
        0x17 => rgb(159  74   0)
        0x18 => rgb(109  92   0)
        0x19 => rgb(54  109   0)
        0x1a => rgb(7   119   4)
        0x1b => rgb(0   121  61)
        0x1c => rgb(0   114 125)
        0x1d => rgb(0     0   0)
        0x1e => rgb(0     0   0)
        0x1f => rgb(0     0   0)
        0x20 => rgb(254 254 255)
        0x21 => rgb(93  179 255)
        0x22 => rgb(143 161 255)
        0x23 => rgb(200 144 255)
        0x24 => rgb(247 133 250)
        0x25 => rgb(255 131 192)
        0x26 => rgb(255 139 127)
        0x27 => rgb(239 154  73)
        0x28 => rgb(189 172  44)
        0x29 => rgb(133 188  47)
        0x2a => rgb(85  199  83)    
        0x2b => rgb(60  201 140)    
        0x2c => rgb(62  194 205)
        0x2d => rgb(78   78  78)
        0x2e => rgb(0     0   0)
        0x2f => rgb(0     0   0)
        0x30 => rgb(254 254 255)
        0x31 => rgb(188 223 255)
        0x32 => rgb(209 216 255)
        0x33 => rgb(232 209 255)
        0x34 => rgb(251 205 253)
        0x35 => rgb(255 204 229)
        0x36 => rgb(255 207 202)
        0x37 => rgb(248 213 180)
        0x38 => rgb(228 220 168)
        0x39 => rgb(204 227 169)
        0x3a => rgb(185 232 184)    
        0x3b => rgb(174 232 208)    
        0x3c => rgb(175 229 234)
        0x3d => rgb(182 182 182)
        0x3e => rgb(0    0    0)
        0x3f => rgb(0    0    0)
        else => {
            println("ERROR: incorrect palette for rgb")
            yield rgb(0, 0, 0)
        }
    }
}
